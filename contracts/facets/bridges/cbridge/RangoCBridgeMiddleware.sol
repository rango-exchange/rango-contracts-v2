// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity 0.8.16;

import "./im/message/framework/MessageReceiverApp.sol";
import "./im/message/framework/MessageSenderApp.sol";
import "../../../libraries/LibInterchain.sol";
import "../../../utils/ReentrancyGuard.sol";
import "../../base/RangoAccessManagerFacet.sol";
import "../../base/RangoBaseInterchainMiddleware.sol";

/// @title The middleware contract that handles Rango's interaction with cBridge.
/// @author George
/// @dev this contract works directly with cBridge and messagebus.
///      Note that this is not a facet and should be deployed separately.
contract RangoCBridgeMiddleware is RangoBaseInterchainMiddleware, IRango, MessageSenderApp, MessageReceiverApp, ReentrancyGuard {

    /// @dev keccak256("exchange.rango.middleware.cbridge")
    bytes32 internal constant CBIRDGE_MIDDLEWARE_NAMESPACE = hex"2ba094f4e7908864b6d0bf1b955a13285820ecdae1501be90101739a37f73d34";

    struct RangoCBridgeMiddlewareStorage {
        address cBridgeAddress;
        address rangoDiamond;
    }

    function initCBridgeMiddleware(
        address _owner,
        address _cBridgeAddress,
        address _cBridgeMessageBusAddress,
        address _rangoDiamond,
        address _weth
    ) external onlyOwner {
        initBaseMiddleware(_owner, _rangoDiamond, _weth);
        updateCBridgeAddressInternal(_cBridgeAddress);
        setMessageBusInternal(_cBridgeMessageBusAddress);
    }

    /// Events

    /// @notice Emits when the cBridge address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event CBridgeAddressUpdated(address oldAddress, address newAddress);
    /// @notice A series of events with different status value to help us track the progress of cross-chain swap
    /// @param id The transferId generated by cBridge
    /// @param token The token address in the current network that is being bridged
    /// @param outputAmount The latest observed amount in the path, aka: input amount for source and output amount on dest
    /// @param destination The destination address that received the money, ZERO address if not sent to the end-user yet
    event CBridgeIMStatusUpdated(bytes32 id, address token, uint256 outputAmount, IRango.CrossChainOperationStatus status, address destination);
    /// @notice A simple cBridge.send scenario
    /// @param receiver The wallet address of receiver on the destination
    /// @param token The address of token on the source chain
    /// @param amount The input amount sent to the bridge
    /// @param dstChainId The network id of destination chain
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    event CBridgeSend(address receiver, address token, uint256 amount, uint64 dstChainId, uint64 nonce, uint32 maxSlippage);

    /// Administration & Control

    /// @notice Updates the address of cBridge contract
    /// @param newAddress The new address of cBridge contract
    function updateCBridgeAddress(address newAddress) external onlyOwner {
        updateCBridgeAddressInternal(newAddress);
    }
    /// @notice Updates the address of messageBus
    /// @param _messageBus The new address of messageBus
    function setMessageBus(address _messageBus) external onlyOwner {
        setMessageBusInternal(_messageBus);
    }

    /// @inheritdoc IMessageReceiverApp
    /// @dev We also send a message to dApp if dAppMessage is valid
    /// @dev We refund the money back to the message.originalSender which is the source wallet address or any wallet that dapp likes to be receiver of the refund
    function executeMessageWithTransferRefund(
        address token,
        uint256 amount,
        bytes calldata message,
        address // executor
    ) external payable override onlyMessageBus nonReentrant returns (ExecutionStatus) {
        Interchain.RangoInterChainMessage memory m = abi.decode((message), (Interchain.RangoInterChainMessage));

        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();
        address fromToken = token;
        if (token == baseStorage.WETH) {
            if (IERC20(token).balanceOf(address(this)) < amount) {
                if (address(this).balance >= amount) {
                    fromToken = LibSwapper.ETH;
                } else {
                    revert("Neither WETH nor ETH were found on contract");
                }
            }
        }

        LibInterchain._sendTokenWithDApp(
            fromToken,
            amount,
            m.originalSender,
            m.dAppMessage,
            m.dAppSourceContract,
            IRangoMessageReceiver.ProcessStatus.REFUND_IN_SOURCE
        );

        emit RangoBridgeCompleted(
            m.requestId,
            fromToken,
            m.originalSender,
            m.recipient,
            amount,
            IRango.CrossChainOperationStatus.RefundInSource,
            m.dAppTag
        );
        return ExecutionStatus.Success;
    }

    /// @inheritdoc IMessageReceiverApp
    /**
     * @dev If our message contains a uniswap-like DEX call on the destination we also perform it here
     * There are also some flags such as:
     * 1. message.bridgeNativeOut which indicates that bridge sent native token to us, so we unwrap it if required
     * 2. message.nativeOut which indicates that we should send native token to end-user/dapp so we unwrap it if needed
     */
    function executeMessageWithTransfer(
        address, // sender
        address token,
        uint256 amount,
        uint64 srcChainId,
        bytes memory message,
        address // executor
    ) external payable override onlyMessageBus nonReentrant returns (ExecutionStatus) {
        Interchain.RangoInterChainMessage memory m = abi.decode((message), (Interchain.RangoInterChainMessage));
        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(token, amount, m);

        emit RangoBridgeCompleted(
            m.requestId,
            receivedToken,
            m.originalSender,
            m.recipient,
            dstAmount,
            status,
            m.dAppTag
        );
        // always return success since swap failure is already handled in-place
        return ExecutionStatus.Success;
    }

    /// @inheritdoc IMessageReceiverApp
    /// @dev In case of failure in the destination, we only send money to the end-user in the destination
    function executeMessageWithTransferFallback(
        address, // sender
        address token, // token
        uint256 amount, // amount
        uint64 srcChainId,
        bytes memory message,
        address // executor
    ) external payable override onlyMessageBus nonReentrant returns (ExecutionStatus) {
        Interchain.RangoInterChainMessage memory m = abi.decode((message), (Interchain.RangoInterChainMessage));
        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();

        address sourceToken = m.bridgeRealOutput == LibSwapper.ETH && token == baseStorage.WETH ? LibSwapper.ETH : token;

        LibInterchain._sendTokenWithDApp(
            sourceToken,
            amount,
            m.recipient,
            m.dAppMessage,
            m.dAppSourceContract,
            IRangoMessageReceiver.ProcessStatus.REFUND_IN_DESTINATION
        );

        emit RangoBridgeCompleted(
            m.requestId,
            token,
            m.originalSender,
            m.recipient,
            amount,
            IRango.CrossChainOperationStatus.RefundInDestination,
            m.dAppTag
        );
        return ExecutionStatus.Fail;
    }

    /// @notice Computes the sgnFee for a given message based on messageBus formula
    /// @param imMessage The message that fee is computed for
    function computeCBridgeSgnFee(Interchain.RangoInterChainMessage memory imMessage) external view returns (uint) {
        bytes memory msgBytes = abi.encode(imMessage);
        return IMessageBus(getMsgBusAddress()).calcFee(msgBytes);
    }

    /// @notice Executes a bridging via cBridge
    /// @param receiver The receiver address in the destination chain
    /// @param token The token address to be bridged
    /// @param amount The amount of the token to be bridged
    /// @param dstChainId The network id of destination chain, ex: 10 for optimism
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    function doSend(
        address receiver,
        address token,
        uint256 amount,
        uint64 dstChainId,
        uint64 nonce,
        uint32 maxSlippage
    ) external payable nonReentrant onlyDiamond {
        address cBridgeAddress = getRangoCBridgeMiddlewareStorage().cBridgeAddress;
        require(cBridgeAddress != LibSwapper.ETH, 'cBridge address not set');
        if (token != LibSwapper.ETH) {
            LibSwapper.approveMax(token, cBridgeAddress, amount);
            IBridge(cBridgeAddress).send(receiver, token, amount, dstChainId, nonce, maxSlippage);
        } else {
            IBridge(cBridgeAddress).sendNative{value : amount}(receiver, amount, dstChainId, nonce, maxSlippage);
        }
        emit CBridgeSend(receiver, token, amount, dstChainId, nonce, maxSlippage);
    }

    /// @notice Executes a cBridgeIM call
    /// @param fromToken The address of source token to bridge
    /// @param inputAmount The amount of input to be bridged
    /// @param receiverContract Our RangoCBridge.sol contract in the destination chain that will handle the destination logic
    /// @param dstChainId The network id of destination chain, ex: 10 for optimism
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    /// @param sgnFee The fee amount (in native token) that cBridge IM charges for delivering the message
    /// @param imMessage Our custom interchain message that contains all the required info for the RangoCBridge.sol on the destination
    function doCBridgeIM(
        address fromToken,
        uint inputAmount,
        address receiverContract, // The receiver app contract address, not recipient
        uint64 dstChainId,
        uint64 nonce,
        uint32 maxSlippage,
        uint sgnFee,

        Interchain.RangoInterChainMessage memory imMessage
    ) external payable nonReentrant onlyDiamond {
        require(msg.value >= sgnFee, 'sgnFee is bigger than the input');
        address cBridgeAddress = getRangoCBridgeMiddlewareStorage().cBridgeAddress;
        address messageBus = getMsgBusAddress();

        require(messageBus != LibSwapper.ETH, 'cBridge message-bus address not set');
        require(cBridgeAddress != LibSwapper.ETH, 'cBridge address not set');
        require(imMessage.dstChainId == dstChainId, 'dstChainId and imMessage.dstChainId do not match');

        if (fromToken != LibSwapper.ETH)
            LibSwapper.approveMax(fromToken, cBridgeAddress, inputAmount);

        bytes memory message = abi.encode(imMessage);

        sendMessageWithTransfer(
            receiverContract,
            fromToken,
            inputAmount,
            dstChainId,
            nonce,
            maxSlippage,
            message,
            MsgDataTypes.BridgeSendType.Liquidity,
            sgnFee
        );
    }

    function updateCBridgeAddressInternal(address newAddress) private {
        require(newAddress != address(0), "Invalid CBridge Address");
        RangoCBridgeMiddlewareStorage storage s = getRangoCBridgeMiddlewareStorage();
        address oldAddress = s.cBridgeAddress;
        s.cBridgeAddress = newAddress;
        emit CBridgeAddressUpdated(oldAddress, newAddress);
    }

    /// @dev fetch local storage
    function getRangoCBridgeMiddlewareStorage() private pure returns (RangoCBridgeMiddlewareStorage storage s) {
        bytes32 namespace = CBIRDGE_MIDDLEWARE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}